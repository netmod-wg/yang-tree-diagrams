# -*- org -*-

This document captures the current syntax used in YANG module Tree
Diagrams.  The purpose of the document is to provide a single location
for this definition.  This syntax may be updated from time to time
based on the evolution of the YANG language.

* Introduction

YANG Tree Diagrams were first published in ^RFC7223^.  Such diagrams
are commonly used to provided a simplified graphical representation of
a data model and can be automatically generated via tools such as
"pyang".  (See <https://github.com/mbj4668/pyang>).  This document
provides the syntax used in YANG Tree Diagrams.  It is expected that
this document will be updated or replaced as changes to the YANG
language, see ^RFC7950^, necessitate.

Today's common practice is include the definition of the syntax used
to represent a YANG module in every document that provides a tree
diagram.  This practice has several disadvantages and the purpose of
the document is to provide a single location for this definition.  It
is not the intent of this document to restrict future changes, but
rather to ensure such changes are easily identified and suitably
agreed upon.

An example tree diagram can be found in ^RFC7223^ Section 3.  A
portion of which follows:

  +--rw interfaces
  |  +--rw interface* [name]
  |     +--rw name                        string
  |     +--rw description?                string
  |     +--rw type                        identityref
  |     +--rw enabled?                    boolean
  |     +--rw link-up-down-trap-enable?   enumeration

The remainder of this document contains YANG Tree Diagram syntax
based on output from pyang version 1.7.1.

* Tree Diagram Syntax

This section provides the meaning of the symbols used in YANG Tree
diagrams.

A full tree diagram of a module represents all elements.  It includes
the name of the module and sections for top level module statements
(typically containers), augmentations, rpcs and notifications all
identified under a module statement.  Module trees may be included in a
document as a whole, by one or more sections, or even subsets of nodes.

A module is identified by "module:" followed the module-name.  This is
followed by one or more sections, in order:

+ The top-level data nodes defined in the module, offset by 4 spaces.
+ Augmentations, offset by 2 spaces and identified by the keyword
  "augment" followed by the augment target node and a colon (':')
  character.
+ RPCs, offset by 2 spaces and identified by "rpcs:".
+ Notifications, offset by 2 spaces and identified by
  "notifications:".
+ Groupings, offset by 2 spaces, and identified by the keyword
  "grouping" followed by the name of the grouping and a colon (':')
  character.
+ yang-data, offset by 2 spaces, and identified by the keyword
  "yang-data" followed by the name of the yang-data structure and a
  colon (':') character.

The relative organization of each section is provided using a text-based
format that is typical of a file system directory tree display command.
Each node in the tree is prefaces with '+--'.  Schema nodes that are
children of another node are offset from the parent by 3 spaces.  Schema
peer nodes separated are listed with the same space offset and, when
separated by lines, linked via a vertical bar ('|') character.

The full format, including spacing conventions is:

module: <module-name>
    +--<node>
    |  +--<node>
    |     +--<node>
    +--<node>
       +--<node>
          +--<node>

  augment <target-node>:
    +--<node>
       +--<node>
       +--<node>
          +--<node>
  augment <target-node>:
    +--<node>

  rpcs:
    +--<rpc-node>
    +--<rpc-node>
       +--<node>
       |  +--<node>
       +--<node>

  notifications:
    +--<notification-node>
    +--<notification-node>
       +--<node>
       |  +--<node>
       +--<node>

  grouping <grouping-name>:
    +--<node>
       +--<node>
       |  +--<node>
       +--<node>
  grouping <grouping-name>:
    +--<node>

  yang-data <yang-data-name>:
    +--<node>
       +--<node>
       |  +--<node>
       +--<node>
  yang-data <yang-data-name>:
    +--<node>

** Submodules

Submodules are represented in the same fashion as modules, but are
identified by "submodule:" followed the (sub)module-name.  For example:

submodule: <module-name>
  +--<node>
  |  +--<node>
  |     +--<node>

** Groupings

Nodes within a used grouping are expanded as if the nodes were defined
at the location of the uses statement.

Groupings may optionally be present in the "groupings" section.

** yang-data

If the module defines a "yang-data" structure ^RFC8040^, these
structures may optionally be present in the "yang-data" section.

** Collapsed Node Representation

At times when the composition of the nodes within a module schema are
not important in the context of the presented tree, peer nodes and their
children can be collapsed using the notation '...' in place of the
text lines used to represent the summarized nodes.  For example:

  +--<node>
  |  ...
  +--<node>
     +--<node>
        +--<node>

** Comments

Single line comments, starting with "//" and ending at the end of the
line, may be used in the tree notation.

** Node Representation

Each node in a YANG module is printed as:

  <status> <flags> <name> <opts> <type> <if-features>

    <status> is one of:

      +  for current
      x  for deprecated
      o  for obsolete

    <flags> is one of:
      rw  for configuration data
      ro  for non-configuration data
      -x  for rpcs and actions
      -n  for notifications
      mp  for nodes containing schema mount points

    <name> is the name of the node
      (<name>) means that the node is a choice node
     :(<name>) means that the node is a case node

      If the node is augmented into the tree from another module,
      its name is printed as <prefix>:<name>.

    <opts> is one of:
      ?  for an optional leaf, choice, anydata or anyxml
      !  for a presence container
      *  for a leaf-list or list
      [<keys>] for a list's keys
      /  for a mounted node directly under a mount point

    <type> is the name of the type for leafs and leaf-lists

      If the type is a leafref, the type is printed as "-> TARGET",
      where TARGET is either the leafref path, with prefixed removed
      if possible.

    <if-features> is the list of features this node depends on,
      printed within curly brackets and a question mark "{...}?"

* Usage Guidelines For RFCs

This section provides general guidelines related to the use of tree
diagrams in RFCs.  This section covers [Authors' note: will cover]
different types of trees and when to use them; for example, complete
module trees, subtrees, trees for groupings etc.

** Wrapping Long Lines

Internet Drafts and RFCs limit the number of characters that may in a
line of text to 72 characters.  When the tree representation of a node
results in line being longer than this limit the line should be broken
between <opts> and <type>.  The type should be indented so that the new
line starts below <name> with a white space offset of at least two
characters. For example:

  notifications:
    +---n yang-library-change
       +--ro module-set-id
               -> /modules-state/module-set-id

The previously 'pyang' command can be helpful in producing such output,
for example the above example was produced using:

  pyang -f tree --tree-line-length 50 < ietf-yang-library.yang

* YANG Schema Mount Tree Diagrams

YANG Schema Mount is defined in ^I-D.ietf-netmod-schema-mount^ and
warrants some specific discussion. Schema mount document is a generic
mechanism that allows for mounting one data model consisting of any
number of YANG modules at a specified location of another (parent)
schema. Modules containing mount points will identify container or list
nodes which are used as mount points by name using the "mount-point"
extension. These mount points should be
identified, as indicated above using the 'mp' flag.  For example:

    module: ietf-network-instance
      +--rw network-instances
         +--rw network-instance* [name]
            +--rw name           string
            +--rw enabled?       boolean
            +--rw description?   string
            +--rw (ni-type)?
            +--rw (root-type)
               +--:(vrf-root)
               |  +--mp vrf-root

Note that a mount point definition alone is not sufficient to identify
if a mounted modules are used for configuration or for non-configuration
data.  This is determined by the yang-schema-mount module 'config' leaf
associated with the specific mount point.

In describing the intended use of a module containing a mount point, it
is helpful to show how the mount point would look with mounted modules.
In such cases, the mount point should be treated much like a container
that uses a grouping.  The flags should also be set based on the
'config' leaf mentioned above, and the mount realted options indicated
above should be shown.  For example, the following represents
the prior example with YANG Routing and OSPF modules mounted, YANG
Interface module nodes accessible via a parent-reference, and
'config' indicating true:

    module: ietf-network-instance
      +--rw network-instances
         +--rw network-instance* [name]
            +--rw name           string
            +--rw enabled?       boolean
            +--rw description?   string
            +--rw (ni-type)?
            +--rw (root-type)
               +--:(vrf-root)
                  +--mp vrf-root
                     +--ro rt:routing-state/
                     |  ...
                     +--rw rt:routing/
                        ...

The with 'config' indicating false, the only change would be to the flag
on the rt:routing node:

                     +--ro rt:routing/

* IANA Considerations

There are no IANA requests or assignments included in this document.



{{document:
    name ;
    ipr trust200902;
    category std;
    references references.xml;
    title "YANG Tree Diagrams";
    abbreviation "YANG Tree Diagrams";
    contributor "author:Martin Bjorklund:Tail-f Systems:mbj@tail-f.com";
    contributor "editor:Lou Berger:LabN Consulting, L.L.C.:lberger@labn.net";
}}
